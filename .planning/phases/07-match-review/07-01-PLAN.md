---
phase: 07-match-review
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/rfp.ts
  - src/app/(dashboard)/rfps/[id]/matches/page.tsx
  - src/app/(dashboard)/rfps/[id]/matches/actions.ts
autonomous: true

must_haves:
  truths:
    - "User can navigate to /rfps/{jobId}/matches and see job info"
    - "Page fetches RFP items with nested match suggestions"
    - "Server Actions update database when accept/reject is called"
    - "Cache invalidates after Server Action completes"
  artifacts:
    - path: "src/types/rfp.ts"
      provides: "Type definitions for RFP items and match suggestions"
      exports: ["RFPItem", "MatchSuggestion", "RFPItemWithMatches"]
    - path: "src/app/(dashboard)/rfps/[id]/matches/page.tsx"
      provides: "Match review page with data fetching"
      min_lines: 50
    - path: "src/app/(dashboard)/rfps/[id]/matches/actions.ts"
      provides: "Server Actions for accept/reject operations"
      exports: ["acceptMatch", "rejectMatch"]
  key_links:
    - from: "src/app/(dashboard)/rfps/[id]/matches/page.tsx"
      to: "Supabase rfp_items table"
      via: "nested select query"
      pattern: "rfp_match_suggestions.*"
    - from: "src/app/(dashboard)/rfps/[id]/matches/actions.ts"
      to: "Next.js cache"
      via: "revalidatePath"
      pattern: "revalidatePath.*matches"
---

<objective>
Create the match review page foundation with types, data fetching, and Server Actions for accept/reject operations.

Purpose: Establish the page route and mutation logic so interactive components (Plan 02) can build on a working foundation.

Output:
- TypeScript types for RFP items and match suggestions
- Server Component page at /rfps/[id]/matches with nested data fetch
- Server Actions for accepting and rejecting matches with proper cache invalidation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase context (locked decisions)
@.planning/phases/07-match-review/07-CONTEXT.md
@.planning/phases/07-match-review/07-RESEARCH.md

# Existing patterns
@src/app/(dashboard)/rfps/page.tsx
@src/app/(dashboard)/rfps/components/rfp-jobs-list.tsx
@src/lib/supabase/server.ts

# Database schema reference
@supabase/migrations/20260122_rfp_match_results.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for RFP match review</name>
  <files>src/types/rfp.ts</files>
  <action>
Create a new file `src/types/rfp.ts` with three type definitions that match the database schema from `20260122_rfp_match_results.sql`:

1. **RFPItem** - All columns from rfp_items table:
   - id, job_id (strings/UUIDs)
   - lote_pedido, posicao_pedido (number | null)
   - artigo_pedido, descricao_pedido, especificacoes_tecnicas (string | null, except descricao_pedido which is required string)
   - quantidade_pedido (number | null)
   - preco_artigo, preco_posicao, preco_lote (number | null)
   - review_status: 'pending' | 'accepted' | 'rejected' | 'manual'
   - selected_match_id: string | null
   - created_at, updated_at (string)

2. **MatchSuggestion** - All columns from rfp_match_suggestions table:
   - id, rfp_item_id (strings/UUIDs)
   - codigo_spms, artigo, descricao (string | null)
   - unidade_venda (string | null)
   - quantidade_disponivel (number | null)
   - preco (number | null)
   - similarity_score (number, 0-1)
   - match_type (string | null)
   - rank (number)
   - status: 'pending' | 'accepted' | 'rejected'
   - created_at (string)

3. **RFPItemWithMatches** - extends RFPItem with:
   - rfp_match_suggestions: MatchSuggestion[]

Export all three types.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify types compile without errors.
  </verify>
  <done>
Types compile and can be imported from '@/types/rfp'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Server Actions for accept/reject</name>
  <files>src/app/(dashboard)/rfps/[id]/matches/actions.ts</files>
  <action>
Create a Server Actions file with 'use server' directive containing two functions:

**acceptMatch(jobId: string, rfpItemId: string, matchId: string)**:
1. Create Supabase server client
2. Verify user is authenticated via getUser()
3. Update the selected match's status to 'accepted' in rfp_match_suggestions
4. Update all OTHER matches for this rfp_item_id to status 'rejected' (auto-reject siblings)
5. Update the rfp_item's review_status to 'accepted' and selected_match_id to the matchId
6. Call `revalidatePath(/rfps/${jobId}/matches)` to invalidate cache
7. Return `{ success: true }` or `{ success: false, error: string }`

**rejectMatch(jobId: string, rfpItemId: string, matchId: string)**:
1. Create Supabase server client
2. Verify user is authenticated
3. Update this specific match's status to 'rejected' in rfp_match_suggestions
4. Query remaining matches: SELECT id WHERE rfp_item_id = X AND status != 'rejected'
5. If no remaining non-rejected matches:
   - Update rfp_item's review_status to 'rejected', selected_match_id to null
6. If there ARE remaining matches and this was the accepted match:
   - Update rfp_item's selected_match_id to null, review_status to 'pending'
7. Call revalidatePath
8. Return success/error

Import createClient from '@/lib/supabase/server'. Use proper error handling - wrap DB operations in try/catch.

Reference RESEARCH.md Pattern 2 for the exact implementation pattern with step-by-step database updates.
  </action>
  <verify>
File exists at correct path. Run `npx tsc --noEmit` to verify Server Actions compile without errors.
  </verify>
  <done>
acceptMatch and rejectMatch are exported Server Actions that update Supabase and revalidate cache.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create match review page with data fetching</name>
  <files>src/app/(dashboard)/rfps/[id]/matches/page.tsx</files>
  <action>
Create a Server Component page at the dynamic route:

**Data fetching (async Server Component):**
1. Extract jobId from params (Next.js 15: `params: Promise<{ id: string }>`, await it)
2. Create Supabase server client
3. Get authenticated user, redirect to /login if not authenticated
4. Fetch job from rfp_upload_jobs where id = jobId AND user_id = user.id
5. If no job found, call `notFound()` from next/navigation
6. Fetch items with nested matches using Supabase nested select:
   ```
   .from('rfp_items')
   .select(`*, rfp_match_suggestions (*)`)
   .eq('job_id', jobId)
   .order('lote_pedido', { ascending: true })
   .order('posicao_pedido', { ascending: true })
   ```
7. Sort each item's rfp_match_suggestions by similarity_score DESC (client-side sort after fetch)
8. Calculate review progress: totalItems and reviewedItems (where review_status !== 'pending')

**Page layout (placeholder for Plan 02 components):**
- Header with back button (Link to /rfps), title "Review Matches", and progress text
- Use ArrowLeft from lucide-react for back icon
- Show job.file_name and "X of Y items reviewed" in subtitle
- Map over items and render a placeholder Card for each (Plan 02 will replace with RFPItemCard)
- Empty state if no items: "No items found for this RFP."

Import types from '@/types/rfp'. Use existing UI components from '@/components/ui/*'.

Do NOT create the RFPItemCard, MatchSuggestionRow, or ConfidenceBar components yet - those are Plan 02. Just render a simple Card with the item's descricao_pedido and a "Matches: {count}" text as placeholder.
  </action>
  <verify>
1. Start dev server: `npm run dev`
2. Navigate to an existing job's match page (use a completed job ID from database)
3. Page loads without errors and shows placeholder cards
4. Verify Supabase query returns items (check console or add temporary console.log)
  </verify>
  <done>
Page renders at /rfps/[id]/matches, fetches job and items with nested matches, shows placeholder UI.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes (no type errors)
2. `npm run lint` passes
3. Page at /rfps/{jobId}/matches loads with placeholder cards
4. Server Actions exist and can be imported (test via temporary button in Plan 02)
</verification>

<success_criteria>
- [ ] Types defined in src/types/rfp.ts: RFPItem, MatchSuggestion, RFPItemWithMatches
- [ ] Server Actions in actions.ts: acceptMatch, rejectMatch with revalidatePath
- [ ] Page fetches items with nested matches in single query
- [ ] Page shows progress (X of Y reviewed)
- [ ] 404 returned for non-existent or unauthorized job IDs
- [ ] Empty state displayed when job has no items
</success_criteria>

<output>
After completion, create `.planning/phases/07-match-review/07-01-SUMMARY.md`
</output>
