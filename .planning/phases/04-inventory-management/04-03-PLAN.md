---
phase: 04-inventory-management
plan: 03
type: execute
wave: 3
depends_on: [04-01, 04-02]
files_modified:
  - src/app/(dashboard)/inventory/components/permission-gate.tsx
  - src/app/(dashboard)/inventory/page.tsx
autonomous: true

must_haves:
  truths:
    - "Only admin users see the Upload CSV button"
    - "All authenticated users can see and use the Export button"
    - "Server action rejects non-admin upload attempts"
    - "Inventory page displays upload and export buttons in header"
  artifacts:
    - path: "src/app/(dashboard)/inventory/components/permission-gate.tsx"
      provides: "Conditional rendering wrapper based on user role"
      exports: ["PermissionGate"]
    - path: "src/app/(dashboard)/inventory/page.tsx"
      provides: "Updated inventory page with upload and export integration"
      min_lines: 100
  key_links:
    - from: "src/app/(dashboard)/inventory/page.tsx"
      to: "src/lib/auth/utils.ts"
      via: "getUserRole import"
      pattern: "import.*getUserRole.*from.*lib/auth/utils"
    - from: "src/app/(dashboard)/inventory/page.tsx"
      to: "permission-gate.tsx"
      via: "PermissionGate component"
      pattern: "<PermissionGate"
    - from: "src/app/(dashboard)/inventory/page.tsx"
      to: "export-button.tsx"
      via: "ExportButton component"
      pattern: "<ExportButton"
    - from: "src/app/(dashboard)/inventory/page.tsx"
      to: "csv-upload-button.tsx"
      via: "CSVUploadButton component"
      pattern: "<CSVUploadButton"
---

<objective>
Integrate permission-based access control and assemble all components into inventory page

Purpose: Complete Phase 4 by wiring up upload and export functionality with proper RBAC, ensuring only admins can modify inventory.

Output: Fully functional inventory page with role-based upload button, export dropdown, and proper access control.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-inventory-management/04-RESEARCH.md
@.planning/phases/04-inventory-management/04-01-SUMMARY.md
@.planning/phases/04-inventory-management/04-02-SUMMARY.md
@src/lib/auth/utils.ts
@src/app/(dashboard)/inventory/page.tsx
@src/app/(dashboard)/inventory/components/inventory-table.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PermissionGate component</name>
  <files>src/app/(dashboard)/inventory/components/permission-gate.tsx</files>
  <action>
Create a reusable component for conditional rendering based on user role.

**src/app/(dashboard)/inventory/components/permission-gate.tsx:**
```typescript
import { ReactNode } from 'react'
import { UserRole } from '@/lib/auth/utils'

interface PermissionGateProps {
  children: ReactNode
  /** Role required to see children. 'admin' means admin-only, 'user' means any authenticated user */
  requiredRole: 'admin' | 'user'
  /** Current user's role, passed from server component */
  userRole: UserRole | null
  /** Content to show if user doesn't have permission (optional) */
  fallback?: ReactNode
}

/**
 * Conditionally render children based on user role
 *
 * Role hierarchy: admin > user > null (unauthenticated)
 * - admin can access everything
 * - user can access 'user' level and below
 * - null (not logged in) can access nothing gated
 *
 * @example
 * // Only admin sees this
 * <PermissionGate requiredRole="admin" userRole={userRole}>
 *   <UploadButton />
 * </PermissionGate>
 *
 * // Any authenticated user sees this
 * <PermissionGate requiredRole="user" userRole={userRole}>
 *   <ExportButton />
 * </PermissionGate>
 */
export function PermissionGate({
  children,
  requiredRole,
  userRole,
  fallback = null,
}: PermissionGateProps) {
  // Not authenticated - show nothing
  if (!userRole) {
    return <>{fallback}</>
  }

  // Admin can access everything
  if (userRole === 'admin') {
    return <>{children}</>
  }

  // Check specific role requirement
  // 'user' role can access 'user' level content
  if (requiredRole === 'user' && userRole === 'user') {
    return <>{children}</>
  }

  // User doesn't have required permission
  return <>{fallback}</>
}
```

This component:
- Takes the user role from parent (server component passes it down)
- Implements role hierarchy (admin > user)
- Provides optional fallback content
- Is a simple synchronous component (no hooks, no client directive needed)
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
File exists at src/app/(dashboard)/inventory/components/permission-gate.tsx.
  </verify>
  <done>
PermissionGate component created with:
- Role hierarchy support (admin > user)
- Optional fallback rendering
- TypeScript types matching UserRole from auth/utils
- Documentation with usage examples
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate components into inventory page</name>
  <files>src/app/(dashboard)/inventory/page.tsx</files>
  <action>
Update the inventory page to include upload button (admin-only), export button (all users), and wire up the server action.

**Update src/app/(dashboard)/inventory/page.tsx:**

Add imports at top:
```typescript
import { getUserRole } from '@/lib/auth/utils'
import { PermissionGate } from './components/permission-gate'
import { ExportButton } from './components/export-button'
import { CSVUploadButton } from './components/csv-upload-button'
import { triggerInventoryUpload } from './actions'
```

After fetching data and before the return statement, get user role:
```typescript
// Get user role for permission checks
const userRole = await getUserRole()
```

Create a wrapper function to pass to CSVUploadButton (since server actions need FormData):
```typescript
// Wrapper to convert File to FormData for server action
async function handleUpload(file: File, rowCount: number) {
  'use server'
  const formData = new FormData()
  formData.append('file', file)
  formData.append('rowCount', String(rowCount))
  return triggerInventoryUpload(formData)
}
```

Note: The above won't work because we can't define server actions inside page component body. Instead, modify CSVUploadButton to accept the action directly and construct FormData there.

**Actually, update the approach:**

The CSVUploadButton should construct the FormData and call the action. Update the page to pass the action directly:

Replace the header section in the return statement:
```tsx
<div className="flex items-center justify-between">
  <div>
    <h1 className="text-2xl font-semibold">Inventory</h1>
    <p className="text-muted-foreground">
      Browse and manage your product catalog
    </p>
  </div>

  <div className="flex items-center gap-2">
    {/* Export available to all authenticated users */}
    <ExportButton
      data={data ?? []}
      columnConfig={visibleColumns}
    />

    {/* Upload only for admin users */}
    <PermissionGate requiredRole="admin" userRole={userRole}>
      <CSVUploadButton onUpload={async (file, rowCount) => {
        'use server'
        const formData = new FormData()
        formData.append('file', file)
        formData.append('rowCount', String(rowCount))
        return triggerInventoryUpload(formData)
      }} />
    </PermissionGate>
  </div>
</div>
```

**Actually, inline server actions with closures don't work in this pattern. Better approach:**

Create a separate server action wrapper in actions.ts, and update CSVUploadButton to call it with FormData internally.

**Final approach - Update CSVUploadButton props to accept a simpler signature:**

1. Keep CSVUploadButton accepting the current props
2. In inventory page, create a client wrapper component that handles the FormData conversion

Or simpler: CSVUploadButton already handles the FormData construction. Just need to wire it up.

**Complete updated page.tsx:**
```typescript
import { createClient } from '@/lib/supabase/server'
import { getUserRole } from '@/lib/auth/utils'
import { InventoryTable } from './components/inventory-table'
import { PermissionGate } from './components/permission-gate'
import { ExportButton } from './components/export-button'
import { CSVUploadButton } from './components/csv-upload-button'
import { triggerInventoryUpload } from './actions'
import { InventoryColumnConfig } from '@/lib/supabase/types'

// Force dynamic rendering
export const dynamic = 'force-dynamic'

interface InventoryPageProps {
  searchParams: Promise<Record<string, string | string[] | undefined>>
}

export default async function InventoryPage({
  searchParams,
}: InventoryPageProps) {
  const params = await searchParams
  const page = Math.max(1, parseInt(String(params.page || '1'), 10) || 1)
  const pageSize = Math.min(100, Math.max(1, parseInt(String(params.pageSize || '50'), 10) || 50))
  const search = String(params.search || '').slice(0, 200)
  const sortBy = String(params.sortBy || '')
  const sortOrder = params.sortOrder === 'desc' ? 'desc' : 'asc'
  const category = params.category ? String(params.category) : undefined

  const supabase = await createClient()

  // Get user role for permission checks
  const userRole = await getUserRole()

  // Fetch column configuration
  const { data: columnConfig, error: configError } = await supabase
    .from('inventory_column_config')
    .select('*')
    .order('display_order', { ascending: true })

  if (configError) {
    console.error('Failed to fetch column config:', configError.message)
    throw new Error(
      `Failed to fetch column configuration: ${configError.message}. ` +
      `Please run the inventory_column_config migration in Supabase.`
    )
  }

  const columns = (columnConfig || []) as InventoryColumnConfig[]
  const visibleColumns = columns.filter(c => c.visible)
  const searchableColumns = columns.filter(c => c.searchable)

  // Get the first sortable column as default, or first visible column
  const defaultSortColumn = columns.find(c => c.sortable && c.visible)?.column_name ||
                            visibleColumns[0]?.column_name ||
                            'id'
  const actualSortBy = sortBy && columns.some(c => c.column_name === sortBy && c.sortable)
    ? sortBy
    : defaultSortColumn

  // Build the main query - select all columns, we'll filter in display
  let query = supabase.from('artigos').select('*', { count: 'exact' })

  // Apply search filter across searchable columns
  if (search && searchableColumns.length > 0) {
    const searchConditions = searchableColumns
      .map(col => `${col.column_name}.ilike.%${search}%`)
      .join(',')
    query = query.or(searchConditions)
  }

  // Apply category filter if there's a category column configured
  const categoryColumn = columns.find(c =>
    c.column_name.toLowerCase().includes('categ') ||
    c.column_name.toLowerCase().includes('category')
  )
  if (category && categoryColumn) {
    query = query.eq(categoryColumn.column_name, category)
  }

  // Apply sorting
  query = query.order(actualSortBy, { ascending: sortOrder === 'asc' })

  // Apply pagination
  query = query.range((page - 1) * pageSize, page * pageSize - 1)

  const { data, error, count } = await query

  if (error) {
    console.error('Inventory query error:', {
      message: error.message,
      code: error.code,
    })
    throw new Error(`Failed to fetch inventory: ${error.message}`)
  }

  // Fetch distinct categories for the filter dropdown (if category column exists)
  let categories: string[] = []
  if (categoryColumn) {
    const { data: categoryData } = await supabase
      .from('artigos')
      .select(categoryColumn.column_name)
      .not(categoryColumn.column_name, 'is', null)
      .order(categoryColumn.column_name)

    if (categoryData && Array.isArray(categoryData)) {
      categories = [
        ...new Set(
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (categoryData as any[])
            .map((item) => item[categoryColumn.column_name])
            .filter((v): v is string => typeof v === 'string' && v.length > 0)
        ),
      ]
    }
  }

  return (
    <div className="flex flex-1 flex-col gap-4 p-4">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-semibold">Inventory</h1>
          <p className="text-muted-foreground">
            Browse and manage your product catalog
          </p>
        </div>

        <div className="flex items-center gap-2">
          {/* Export available to all authenticated users */}
          <ExportButton
            data={data ?? []}
            columnConfig={visibleColumns}
          />

          {/* Upload only for admin users */}
          <PermissionGate requiredRole="admin" userRole={userRole}>
            <CSVUploadButton />
          </PermissionGate>
        </div>
      </div>
      <InventoryTable
        data={data ?? []}
        totalCount={count ?? 0}
        categories={categories}
        columnConfig={visibleColumns}
        categoryColumnName={categoryColumn?.column_name}
        initialState={{
          page,
          pageSize,
          search,
          sortBy: actualSortBy,
          sortOrder,
          category: category ?? null,
        }}
      />
    </div>
  )
}
```

**Also update CSVUploadButton to import and use the action directly:**

Update `src/app/(dashboard)/inventory/components/csv-upload-button.tsx`:
```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Upload } from 'lucide-react'
import { CSVUploadDialog } from './csv-upload-dialog'
import { triggerInventoryUpload } from '../actions'
import { toast } from 'sonner'

export function CSVUploadButton() {
  const [open, setOpen] = useState(false)

  const handleUpload = async (file: File, rowCount: number) => {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('rowCount', String(rowCount))

    const result = await triggerInventoryUpload(formData)

    if (result.success) {
      toast.success('Upload started', {
        description: `Processing ${rowCount} rows in background. You'll be notified when complete.`,
      })
    } else {
      toast.error('Upload failed', {
        description: result.error,
      })
    }

    return result
  }

  return (
    <>
      <Button onClick={() => setOpen(true)}>
        <Upload className="mr-2 h-4 w-4" />
        Upload CSV
      </Button>
      <CSVUploadDialog
        open={open}
        onOpenChange={setOpen}
        onUpload={handleUpload}
      />
    </>
  )
}
```

This removes the prop-based onUpload and imports the action directly, which is cleaner.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Run `npm run build` to confirm build succeeds.
Run `npm run dev` and verify:
1. As admin: Both Export and Upload CSV buttons visible
2. As regular user: Only Export button visible
3. Export downloads file with current page data
4. Upload opens dialog with dropzone
  </verify>
  <done>
PermissionGate component wraps Upload button.
Export button visible to all authenticated users.
Upload button visible only to admin users.
Server action enforces admin check (defense in depth).
Full integration complete.
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - build succeeds
3. Run `npm run dev` and test:
   - Navigate to /inventory
   - As admin user: See both Export and Upload CSV buttons
   - As regular user: See only Export button
   - Click Export > Excel - downloads .xlsx file
   - Click Export > CSV - downloads .csv file
   - (Admin) Click Upload CSV - dialog opens
   - (Admin) Drag CSV file - validation runs
   - (Admin) Click Upload - job created, toast shown

Manual verification needed:
- Run migration in Supabase Dashboard
- Set N8N_INVENTORY_WEBHOOK_URL environment variable
- Test with actual n8n workflow
</verification>

<success_criteria>
- PermissionGate component provides role-based rendering
- Inventory page shows Export button to all users
- Inventory page shows Upload CSV button only to admins
- Server action rejects non-admin upload attempts
- All components properly integrated and working
- TypeScript compiles without errors
- Build succeeds
- Requirement INV-10 (permission-based access) complete
- Phase 4 requirements INV-06, INV-07, INV-08, INV-09, INV-10 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/04-inventory-management/04-03-SUMMARY.md`

Phase 4 complete. User must:
1. Run inventory_upload_jobs migration in Supabase Dashboard
2. Set N8N_INVENTORY_WEBHOOK_URL in .env.local
3. Configure n8n workflow to accept webhook and update job status
</output>
