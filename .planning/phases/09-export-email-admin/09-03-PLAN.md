---
phase: 09-export-email-admin
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - src/app/(dashboard)/rfps/components/export-email-dialog.tsx
  - src/app/(dashboard)/rfps/components/confirmation-summary.tsx
  - src/app/(dashboard)/rfps/[id]/matches/export-actions.ts
  - src/types/app-settings.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ExportEmailDialog fetches app_settings on mount to determine recipient configuration"
    - "Dialog adapts to 4 behavior modes: no defaults, locked, add-only, replaceable"
    - "Email chips render as read-only or removable based on configuration"
    - "Users can add additional emails up to max 10 total"
    - "Send button triggers webhook with all recipient emails"
  artifacts:
    - path: "src/app/(dashboard)/rfps/components/export-email-dialog.tsx"
      provides: "Email export dialog with configurable recipients"
      exports: ["ExportEmailDialog"]
    - path: "src/types/app-settings.ts"
      provides: "TypeScript types for app_settings"
      exports: ["AppSettings"]
  key_links:
    - from: "ExportEmailDialog"
      to: "app_settings table"
      via: "Supabase query on mount"
      pattern: "from\\('app_settings'\\)"
    - from: "ExportEmailDialog"
      to: "sendExportEmail"
      via: "Server Action call"
      pattern: "sendExportEmail"
---

<objective>
Create ExportEmailDialog with admin-configurable recipient settings.

Purpose: Allow users to send exports via email with recipients controlled by admin settings.
Output: ExportEmailDialog component with adaptive behavior, types, and integration with ConfirmationSummary.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/plans/2026-01-25-phase9-export-email-admin-design.md
@.planning/phases/09-export-email-admin/09-01-PLAN.md
@.planning/phases/09-export-email-admin/09-02-PLAN.md

# Server action for email sending
@src/app/(dashboard)/rfps/[id]/matches/export-actions.ts

# Supabase client
@src/lib/supabase/browser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppSettings types</name>
  <files>src/types/app-settings.ts</files>
  <action>
Create types file for app_settings:

```typescript
/**
 * App settings from the app_settings table (single-row pattern)
 */
export interface AppSettings {
  id: number
  email_default_recipients: string[]
  email_user_can_edit: boolean
  email_defaults_replaceable: boolean
  updated_at: string
  updated_by: string | null
}

/**
 * Behavior modes for email recipient configuration
 *
 * | Mode | Conditions | UX |
 * |------|------------|-----|
 * | no-defaults | empty recipients | Empty input, user adds 1-10 |
 * | locked | has recipients, !user_can_edit | Read-only chips only |
 * | add-only | has recipients, user_can_edit, !defaults_replaceable | Locked chips + input |
 * | replaceable | has recipients, user_can_edit, defaults_replaceable | Removable chips + input |
 */
export type EmailRecipientMode = 'no-defaults' | 'locked' | 'add-only' | 'replaceable'

/**
 * Derive the email recipient mode from app settings
 */
export function getEmailRecipientMode(settings: AppSettings | null): EmailRecipientMode {
  if (!settings || settings.email_default_recipients.length === 0) {
    return 'no-defaults'
  }
  if (!settings.email_user_can_edit) {
    return 'locked'
  }
  if (!settings.email_defaults_replaceable) {
    return 'add-only'
  }
  return 'replaceable'
}
```
  </action>
  <verify>
File exists: `ls src/types/app-settings.ts`
Exports types: `grep "export interface AppSettings" src/types/app-settings.ts`
Mode function: `grep "getEmailRecipientMode" src/types/app-settings.ts`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>AppSettings type and getEmailRecipientMode function exported</done>
</task>

<task type="auto">
  <name>Task 2: Create ExportEmailDialog component</name>
  <files>src/app/(dashboard)/rfps/components/export-email-dialog.tsx</files>
  <action>
Create the email dialog component:

```typescript
'use client'

import { useState, useMemo, useEffect } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { Badge } from '@/components/ui/badge'
import { Mail, Loader2, Check, AlertCircle, X, Plus } from 'lucide-react'
import { toast } from 'sonner'
import type { RFPItemWithMatches } from '@/types/rfp'
import type { AppSettings } from '@/types/app-settings'
import { getEmailRecipientMode } from '@/types/app-settings'
import {
  transformToExportRows,
  calculateExportSummary,
  generateExcelBase64,
  generateExportFilename,
} from '@/lib/export/rfp-export'
import { sendExportEmail } from '@/app/(dashboard)/rfps/[id]/matches/export-actions'
import { createClient } from '@/lib/supabase/browser'

interface ExportEmailDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  items: RFPItemWithMatches[]
  jobId: string
}

const MAX_EMAILS = 10

export function ExportEmailDialog({ open, onOpenChange, items, jobId }: ExportEmailDialogProps) {
  const [exportMode, setExportMode] = useState<'matched' | 'all'>('matched')
  const [isSending, setIsSending] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const [settings, setSettings] = useState<AppSettings | null>(null)

  // Email state
  const [defaultEmails, setDefaultEmails] = useState<string[]>([])
  const [additionalEmails, setAdditionalEmails] = useState<string[]>([])
  const [newEmail, setNewEmail] = useState('')

  // Fetch settings on mount
  useEffect(() => {
    if (!open) return

    const fetchSettings = async () => {
      setIsLoading(true)
      const supabase = createClient()
      const { data } = await supabase
        .from('app_settings')
        .select('*')
        .eq('id', 1)
        .single()

      if (data) {
        setSettings(data)
        setDefaultEmails(data.email_default_recipients || [])
      }
      setIsLoading(false)
    }

    fetchSettings()
  }, [open])

  const mode = getEmailRecipientMode(settings)
  const allEmails = [...defaultEmails, ...additionalEmails]
  const canAddMore = allEmails.length < MAX_EMAILS && mode !== 'locked'
  const canRemoveDefaults = mode === 'replaceable'

  // Calculate summary
  const { matchedCount, noMatchCount, totalRows } = useMemo(() => {
    const summary = calculateExportSummary(items)
    const matched = summary.confirmedCount + summary.manualCount
    const noMatch = summary.rejectedCount + summary.noMatchCount
    const confirmedOnly = exportMode === 'matched'
    const rows = transformToExportRows(items, confirmedOnly)

    return {
      matchedCount: matched,
      noMatchCount: noMatch,
      totalRows: rows.length,
    }
  }, [items, exportMode])

  const handleAddEmail = () => {
    const email = newEmail.trim().toLowerCase()
    if (!email || !email.includes('@')) {
      toast.error('Introduza um email valido')
      return
    }
    if (allEmails.includes(email)) {
      toast.error('Este email ja foi adicionado')
      return
    }
    if (allEmails.length >= MAX_EMAILS) {
      toast.error(`Maximo de ${MAX_EMAILS} emails`)
      return
    }
    setAdditionalEmails([...additionalEmails, email])
    setNewEmail('')
  }

  const handleRemoveDefault = (email: string) => {
    if (mode !== 'replaceable') return
    setDefaultEmails(defaultEmails.filter(e => e !== email))
  }

  const handleRemoveAdditional = (email: string) => {
    setAdditionalEmails(additionalEmails.filter(e => e !== email))
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleAddEmail()
    }
  }

  const handleSend = async () => {
    if (allEmails.length === 0) {
      toast.error('Adicione pelo menos um destinatario')
      return
    }
    if (totalRows === 0) {
      toast.error('Sem dados para enviar')
      return
    }

    setIsSending(true)
    try {
      const confirmedOnly = exportMode === 'matched'
      const excelBase64 = generateExcelBase64(items, confirmedOnly)
      const fileName = generateExportFilename('RFP_Resultados')
      const summary = calculateExportSummary(items)

      // Send to all emails (webhook handles multiple recipients)
      const result = await sendExportEmail({
        jobId,
        recipientEmail: allEmails.join(','), // Comma-separated for multiple
        fileName,
        excelBase64,
        summary: {
          totalItems: summary.totalItems,
          confirmedCount: summary.confirmedCount,
          rejectedCount: summary.rejectedCount,
          manualCount: summary.manualCount,
          noMatchCount: summary.noMatchCount,
        },
      })

      if (result.success) {
        toast.success(`Email enviado para ${allEmails.length} destinatario(s)`)
        onOpenChange(false)
      } else {
        toast.error(result.error || 'Erro ao enviar email')
      }
    } catch (error) {
      console.error('Send email failed:', error)
      toast.error('Erro ao enviar email')
    } finally {
      setIsSending(false)
    }
  }

  // Reset state when dialog closes
  useEffect(() => {
    if (!open) {
      setAdditionalEmails([])
      setNewEmail('')
    }
  }, [open])

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[480px]">
        <DialogHeader>
          <DialogTitle>Enviar por Email</DialogTitle>
          <DialogDescription>
            Envie os resultados da revisao para os destinatarios.
          </DialogDescription>
        </DialogHeader>

        {isLoading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
          </div>
        ) : (
          <>
            {/* Summary stats */}
            <div className="flex items-center justify-center gap-6 py-3">
              <div className="flex items-center gap-2">
                <div className="flex items-center justify-center h-6 w-6 rounded-full bg-emerald-100">
                  <Check className="h-3.5 w-3.5 text-emerald-600" />
                </div>
                <span className="text-lg font-semibold text-emerald-700">{matchedCount}</span>
                <span className="text-xs text-muted-foreground">Correspondencias</span>
              </div>
              <div className="h-5 w-px bg-border" />
              <div className="flex items-center gap-2">
                <div className="flex items-center justify-center h-6 w-6 rounded-full bg-gray-100">
                  <AlertCircle className="h-3.5 w-3.5 text-gray-500" />
                </div>
                <span className="text-lg font-semibold text-gray-700">{noMatchCount}</span>
                <span className="text-xs text-muted-foreground">Sem correspondencia</span>
              </div>
            </div>

            {/* Export mode selection */}
            <div className="space-y-3 py-3 border-t">
              <Label className="text-sm font-medium">Incluir na exportacao</Label>
              <RadioGroup
                value={exportMode}
                onValueChange={(value) => setExportMode(value as 'matched' | 'all')}
                className="space-y-2"
              >
                <div className="flex items-center space-x-3">
                  <RadioGroupItem value="matched" id="email-matched" />
                  <Label htmlFor="email-matched" className="cursor-pointer font-normal">
                    Apenas correspondencias ({matchedCount})
                  </Label>
                </div>
                <div className="flex items-center space-x-3">
                  <RadioGroupItem value="all" id="email-all" />
                  <Label htmlFor="email-all" className="cursor-pointer font-normal">
                    Todos os produtos ({items.length})
                  </Label>
                </div>
              </RadioGroup>
            </div>

            {/* Email recipients */}
            <div className="space-y-3 py-3 border-t">
              <Label className="text-sm font-medium">
                Destinatarios ({allEmails.length}/{MAX_EMAILS})
              </Label>

              {/* Email chips */}
              {allEmails.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {defaultEmails.map((email) => (
                    <Badge key={email} variant="secondary" className="gap-1 pr-1">
                      {email}
                      {canRemoveDefaults && (
                        <button
                          type="button"
                          onClick={() => handleRemoveDefault(email)}
                          className="ml-1 hover:text-destructive rounded-full"
                        >
                          <X className="h-3 w-3" />
                        </button>
                      )}
                    </Badge>
                  ))}
                  {additionalEmails.map((email) => (
                    <Badge key={email} variant="outline" className="gap-1 pr-1">
                      {email}
                      <button
                        type="button"
                        onClick={() => handleRemoveAdditional(email)}
                        className="ml-1 hover:text-destructive rounded-full"
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
                </div>
              )}

              {/* Email input */}
              {canAddMore && (
                <div className="flex gap-2">
                  <Input
                    type="email"
                    placeholder="email@exemplo.com"
                    value={newEmail}
                    onChange={(e) => setNewEmail(e.target.value)}
                    onKeyDown={handleKeyDown}
                    disabled={isSending}
                    className="flex-1"
                  />
                  <Button
                    type="button"
                    variant="outline"
                    size="icon"
                    onClick={handleAddEmail}
                    disabled={!newEmail || isSending}
                  >
                    <Plus className="h-4 w-4" />
                  </Button>
                </div>
              )}

              {mode === 'locked' && (
                <p className="text-xs text-muted-foreground">
                  Os destinatarios estao definidos pelo administrador.
                </p>
              )}
            </div>
          </>
        )}

        <DialogFooter className="gap-3 pt-2">
          <Button variant="outline" onClick={() => onOpenChange(false)} disabled={isSending}>
            Cancelar
          </Button>
          <Button
            onClick={handleSend}
            disabled={isSending || allEmails.length === 0 || totalRows === 0 || isLoading}
          >
            {isSending ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                A enviar...
              </>
            ) : (
              <>
                <Mail className="mr-2 h-4 w-4" />
                Enviar Email
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

Key behaviors:
- Fetches app_settings on dialog open
- Shows loading state while fetching
- Adapts UI based on mode (locked, add-only, replaceable, no-defaults)
- Default emails from settings shown as secondary badges
- Additional user emails shown as outline badges
- All emails can be removed if replaceable mode
- Only additional emails removable if add-only mode
- No input shown if locked mode
- Max 10 emails total
  </action>
  <verify>
File exists: `ls src/app/(dashboard)/rfps/components/export-email-dialog.tsx`
Export function: `grep "export function ExportEmailDialog" src/app/(dashboard)/rfps/components/export-email-dialog.tsx`
Fetches settings: `grep "from\\('app_settings'\\)" src/app/(dashboard)/rfps/components/export-email-dialog.tsx`
Uses mode function: `grep "getEmailRecipientMode" src/app/(dashboard)/rfps/components/export-email-dialog.tsx`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>ExportEmailDialog component created with all 4 behavior modes and email chip UI</done>
</task>

<task type="auto">
  <name>Task 3: Integrate ExportEmailDialog into ConfirmationSummary</name>
  <files>src/app/(dashboard)/rfps/components/confirmation-summary.tsx</files>
  <action>
Update ConfirmationSummary to use the real ExportEmailDialog:

1. Add import for ExportEmailDialog:
```typescript
import { ExportEmailDialog } from './export-email-dialog'
```

2. Replace the placeholder comment/div with the actual component:
```tsx
<ExportEmailDialog
  open={emailDialogOpen}
  onOpenChange={setEmailDialogOpen}
  items={items}
  jobId={jobId}
/>
```

Ensure both dialogs are rendered after the Card component (same pattern as before).
  </action>
  <verify>
Import present: `grep "ExportEmailDialog" src/app/(dashboard)/rfps/components/confirmation-summary.tsx`
Component rendered: `grep "emailDialogOpen" src/app/(dashboard)/rfps/components/confirmation-summary.tsx`
Both dialogs: `grep -c "Dialog" src/app/(dashboard)/rfps/components/confirmation-summary.tsx` should show 2+
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>ConfirmationSummary integrates ExportEmailDialog with proper props</done>
</task>

</tasks>

<verification>
1. AppSettings type and mode function are exported
2. ExportEmailDialog fetches app_settings on open
3. Dialog shows appropriate UI for each mode:
   - no-defaults: empty input field
   - locked: only chips, no input
   - add-only: locked chips + input
   - replaceable: removable chips + input
4. Email chips show correctly with remove buttons where appropriate
5. Max 10 emails enforced
6. Send button triggers webhook with all emails
7. TypeScript compiles without errors
</verification>

<success_criteria>
- Email dialog adapts to admin configuration
- Users can add emails when allowed
- Default recipients appear as chips
- Send functionality works with multiple recipients
- Clean integration with existing export flow
</success_criteria>

<output>
After completion, create `.planning/phases/09-export-email-admin/09-03-SUMMARY.md`
</output>
