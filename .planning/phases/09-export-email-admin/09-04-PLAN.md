---
phase: 09-export-email-admin
plan: 04
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/lib/export/rfp-export.ts
  - src/types/export-config.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Export functions use database column config instead of hardcoded RFP_EXPORT_COLUMNS"
    - "Column visibility, order, and display names are read from export_column_config table"
    - "Column type formatting (currency, number, date) is applied based on config"
    - "Export still works offline/fallback if config fetch fails (uses defaults)"
  artifacts:
    - path: "src/lib/export/rfp-export.ts"
      provides: "Updated export with dynamic column configuration"
      exports: ["transformToExportRows", "exportRFPToExcel", "generateExcelBase64", "getExportColumnConfig"]
    - path: "src/types/export-config.ts"
      provides: "TypeScript types for export column config"
      exports: ["ExportColumnConfig"]
  key_links:
    - from: "rfp-export.ts"
      to: "export_column_config table"
      via: "Supabase query"
      pattern: "from\\('export_column_config'\\)"
    - from: "transformToExportRows"
      to: "ExportColumnConfig"
      via: "dynamic column mapping"
      pattern: "columnConfig.*forEach"
---

<objective>
Update rfp-export.ts to use database-driven column configuration.

Purpose: Allow admins to control which columns appear in exports and their display names.
Output: Dynamic export generation based on export_column_config table.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/plans/2026-01-25-phase9-export-email-admin-design.md
@.planning/phases/09-export-email-admin/09-01-PLAN.md

# Current export implementation
@src/lib/export/rfp-export.ts

# RFP types for reference
@src/types/rfp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExportColumnConfig types</name>
  <files>src/types/export-config.ts</files>
  <action>
Create types file for export column configuration:

```typescript
/**
 * Export column configuration from export_column_config table
 */
export interface ExportColumnConfig {
  id: number
  source_table: 'rfp_items' | 'rfp_match_suggestions'
  column_name: string
  display_name: string
  visible: boolean
  display_order: number
  column_type: 'text' | 'number' | 'currency' | 'date'
  created_at: string
  updated_at: string
}

/**
 * Merged column data for export row building
 * Combines rfp_item data with matched suggestion data
 */
export interface ExportColumnMapping {
  key: string              // column_name from config
  header: string           // display_name from config
  source: 'rfp_items' | 'rfp_match_suggestions'
  type: 'text' | 'number' | 'currency' | 'date'
}

/**
 * Default columns to use when database config is unavailable
 * Matches the existing RFP_EXPORT_COLUMNS structure
 */
export const DEFAULT_EXPORT_COLUMNS: ExportColumnMapping[] = [
  { key: 'lote_pedido', header: 'Lote', source: 'rfp_items', type: 'number' },
  { key: 'posicao_pedido', header: 'Posicao', source: 'rfp_items', type: 'number' },
  { key: 'artigo_pedido', header: 'Artigo Pedido', source: 'rfp_items', type: 'text' },
  { key: 'descricao_pedido', header: 'Descricao Pedido', source: 'rfp_items', type: 'text' },
  { key: 'quantidade_pedido', header: 'Quantidade', source: 'rfp_items', type: 'number' },
  { key: 'codigo_spms', header: 'Cod. SPMS', source: 'rfp_match_suggestions', type: 'text' },
  { key: 'artigo', header: 'Artigo Match', source: 'rfp_match_suggestions', type: 'text' },
  { key: 'descricao', header: 'Descricao Match', source: 'rfp_match_suggestions', type: 'text' },
  { key: 'preco', header: 'Preco Unit.', source: 'rfp_match_suggestions', type: 'currency' },
  { key: 'similarity_score', header: 'Similaridade', source: 'rfp_match_suggestions', type: 'number' },
  { key: 'match_type', header: 'Tipo', source: 'rfp_match_suggestions', type: 'text' },
]
```
  </action>
  <verify>
File exists: `ls src/types/export-config.ts`
Interface exported: `grep "export interface ExportColumnConfig" src/types/export-config.ts`
Default columns: `grep "DEFAULT_EXPORT_COLUMNS" src/types/export-config.ts`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>Export column config types and defaults are exported</done>
</task>

<task type="auto">
  <name>Task 2: Update rfp-export.ts with dynamic column support</name>
  <files>src/lib/export/rfp-export.ts</files>
  <action>
Update the export module to support database-driven columns:

1. Add imports at top:
```typescript
import { createClient } from '@/lib/supabase/browser'
import type { ExportColumnConfig, ExportColumnMapping } from '@/types/export-config'
import { DEFAULT_EXPORT_COLUMNS } from '@/types/export-config'
```

2. Add new function to fetch column config:
```typescript
/**
 * Fetch export column configuration from database
 * Returns visible columns ordered by display_order
 */
export async function getExportColumnConfig(): Promise<ExportColumnMapping[]> {
  try {
    const supabase = createClient()
    const { data, error } = await supabase
      .from('export_column_config')
      .select('*')
      .eq('visible', true)
      .order('source_table')
      .order('display_order')

    if (error || !data || data.length === 0) {
      console.warn('Using default export columns:', error?.message)
      return DEFAULT_EXPORT_COLUMNS
    }

    // Transform to ExportColumnMapping
    return data.map((col: ExportColumnConfig) => ({
      key: col.column_name,
      header: col.display_name,
      source: col.source_table,
      type: col.column_type,
    }))
  } catch (error) {
    console.warn('Failed to fetch export config, using defaults:', error)
    return DEFAULT_EXPORT_COLUMNS
  }
}
```

3. Add value formatter function:
```typescript
/**
 * Format a value based on column type
 */
function formatValue(value: unknown, type: ExportColumnMapping['type']): string | number | null {
  if (value === null || value === undefined) return null

  switch (type) {
    case 'currency':
      return typeof value === 'number' ? value : parseFloat(String(value)) || null
    case 'number':
      if (typeof value === 'number') {
        // Format similarity score as percentage
        return value <= 1 && value > 0 ? `${Math.round(value * 100)}%` : value
      }
      return parseFloat(String(value)) || null
    case 'date':
      if (value instanceof Date) return value.toISOString()
      return String(value)
    default:
      return String(value)
  }
}
```

4. Update transformToExportRows to accept column config:
```typescript
/**
 * Transform RFP items to flat export rows
 * @param items - RFP items with match suggestions
 * @param confirmedOnly - If true, only include accepted/manual items
 * @param columnConfig - Column configuration (uses defaults if not provided)
 * @returns Array of flat export rows
 */
export function transformToExportRows(
  items: RFPItemWithMatches[],
  confirmedOnly: boolean = false,
  columnConfig: ExportColumnMapping[] = DEFAULT_EXPORT_COLUMNS
): Record<string, unknown>[] {
  const filteredItems = confirmedOnly
    ? items.filter((i) => i.review_status === 'accepted' || i.review_status === 'manual')
    : items

  return filteredItems.map((item) => {
    const match = getSelectedMatch(item)
    const row: Record<string, unknown> = {}

    columnConfig.forEach((col) => {
      let value: unknown

      if (col.source === 'rfp_items') {
        // Get value from item (handle key mapping)
        value = (item as Record<string, unknown>)[col.key]
      } else {
        // Get value from match
        value = match ? (match as Record<string, unknown>)[col.key] : null
      }

      row[col.header] = formatValue(value, col.type)
    })

    // Always add status column (not from config)
    const hasAnyMatch = item.rfp_match_suggestions.length > 0
    row['Status'] = getStatusLabel(item.review_status, hasAnyMatch)

    return row
  })
}
```

5. Update exportRFPToExcel to use dynamic config:
```typescript
/**
 * Export RFP data to Excel file (browser download)
 * @param items - RFP items with match suggestions
 * @param confirmedOnly - If true, only include accepted/manual items
 * @param filename - Base filename (without extension)
 * @param columnConfig - Optional column config (fetches from DB if not provided)
 */
export async function exportRFPToExcel(
  items: RFPItemWithMatches[],
  confirmedOnly: boolean = false,
  filename: string = 'RFP_Resultados',
  columnConfig?: ExportColumnMapping[]
): Promise<void> {
  // Fetch config if not provided
  const config = columnConfig || await getExportColumnConfig()

  const exportData = transformToExportRows(items, confirmedOnly, config)

  // Create workbook and worksheet
  const worksheet = XLSX.utils.json_to_sheet(exportData)
  const workbook = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Resultados RFP')

  // Auto-size columns based on content
  const headers = [...config.map(c => c.header), 'Status']
  const maxWidths = headers.map((header) => {
    const headerWidth = header.length
    const dataWidths = exportData.map((row) => String(row[header] ?? '').length)
    return Math.min(Math.max(headerWidth, ...dataWidths) + 2, 50)
  })
  worksheet['!cols'] = maxWidths.map((w) => ({ wch: w }))

  // Generate buffer and download
  const excelBuffer = XLSX.write(workbook, {
    bookType: 'xlsx',
    type: 'array',
  })

  const blob = new Blob([excelBuffer], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  })

  const dateStr = new Date().toISOString().split('T')[0]
  saveAs(blob, `${filename}_${dateStr}.xlsx`)
}
```

6. Update generateExcelBase64 similarly:
```typescript
/**
 * Generate Excel file as base64 for email attachment
 */
export async function generateExcelBase64(
  items: RFPItemWithMatches[],
  confirmedOnly: boolean = false,
  columnConfig?: ExportColumnMapping[]
): Promise<string> {
  const config = columnConfig || await getExportColumnConfig()
  const exportData = transformToExportRows(items, confirmedOnly, config)

  const worksheet = XLSX.utils.json_to_sheet(exportData)
  const workbook = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Resultados RFP')

  const headers = [...config.map(c => c.header), 'Status']
  const maxWidths = headers.map((header) => {
    const headerWidth = header.length
    const dataWidths = exportData.map((row) => String(row[header] ?? '').length)
    return Math.min(Math.max(headerWidth, ...dataWidths) + 2, 50)
  })
  worksheet['!cols'] = maxWidths.map((w) => ({ wch: w }))

  return XLSX.write(workbook, { bookType: 'xlsx', type: 'base64' })
}
```

7. Keep existing types but deprecate RFP_EXPORT_COLUMNS:
```typescript
/**
 * @deprecated Use getExportColumnConfig() instead
 * Kept for backward compatibility
 */
export const RFP_EXPORT_COLUMNS = [...]
```

Note: The functions are now async since they may fetch config. Update the calling components to handle this.
  </action>
  <verify>
getExportColumnConfig exported: `grep "export async function getExportColumnConfig" src/lib/export/rfp-export.ts`
Uses supabase: `grep "from\\('export_column_config'\\)" src/lib/export/rfp-export.ts`
Async exports: `grep "export async function exportRFPToExcel" src/lib/export/rfp-export.ts`
Uses DEFAULT_EXPORT_COLUMNS: `grep "DEFAULT_EXPORT_COLUMNS" src/lib/export/rfp-export.ts`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>rfp-export.ts uses database config with fallback to defaults</done>
</task>

<task type="auto">
  <name>Task 3: Update ExportDownloadDialog to use async exports</name>
  <files>src/app/(dashboard)/rfps/components/export-download-dialog.tsx</files>
  <action>
Update the dialog to handle async export functions:

1. Update the handleExport function to be async:
```typescript
const handleExport = async () => {
  if (totalRows === 0) {
    toast.error('Sem dados para exportar')
    return
  }

  setIsExporting(true)
  try {
    const confirmedOnly = exportMode === 'matched'
    await exportRFPToExcel(items, confirmedOnly, 'RFP_Resultados')
    toast.success('Ficheiro Excel transferido')
    onOpenChange(false)
  } catch (error) {
    console.error('Export failed:', error)
    toast.error('Erro ao exportar ficheiro')
  } finally {
    setIsExporting(false)
  }
}
```

Remove the setTimeout wrapper since we're now properly awaiting.
  </action>
  <verify>
Async handler: `grep "const handleExport = async" src/app/(dashboard)/rfps/components/export-download-dialog.tsx`
Await export: `grep "await exportRFPToExcel" src/app/(dashboard)/rfps/components/export-download-dialog.tsx`
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>ExportDownloadDialog handles async export functions correctly</done>
</task>

</tasks>

<verification>
1. ExportColumnConfig types are properly defined
2. getExportColumnConfig fetches from database
3. Falls back to DEFAULT_EXPORT_COLUMNS on error
4. transformToExportRows builds rows dynamically from config
5. Column type formatting is applied (currency, number, date, text)
6. Export functions are async and handle config
7. Dialog components updated to use async exports
8. TypeScript compiles without errors
</verification>

<success_criteria>
- Export uses database column configuration
- Visibility, order, and display names are respected
- Graceful fallback to defaults if config unavailable
- No breaking changes to existing export flow
- All export functionality still works
</success_criteria>

<output>
After completion, create `.planning/phases/09-export-email-admin/09-04-SUMMARY.md`
</output>
