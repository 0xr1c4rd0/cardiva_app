---
phase: 08-bulk-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/(dashboard)/rfps/[id]/matches/actions.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "searchInventory returns inventory items matching query across codigo_spms, artigo, descricao"
    - "setManualMatch creates accepted match from inventory item and updates RFP item status to 'manual'"
    - "Manual match replaces any previous selection (rejects siblings)"
  artifacts:
    - path: "src/app/(dashboard)/rfps/[id]/matches/actions.ts"
      provides: "searchInventory and setManualMatch Server Actions"
      exports: ["searchInventory", "setManualMatch", "InventorySearchResult"]
  key_links:
    - from: "setManualMatch"
      to: "rfp_match_suggestions table"
      via: "Supabase insert"
      pattern: "supabase\\.from\\('rfp_match_suggestions'\\)\\.insert"
    - from: "setManualMatch"
      to: "rfp_items table"
      via: "Supabase update with review_status: 'manual'"
      pattern: "review_status: 'manual'"
---

<objective>
Add Server Actions for inventory search and manual match setting.

Purpose: Enable users to manually search the inventory and select a different match when AI suggestions are wrong or missing.
Output: Two new Server Actions (`searchInventory`, `setManualMatch`) exported from existing actions.ts file.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-bulk-operations/08-RESEARCH.md

# Existing actions file to extend
@src/app/(dashboard)/rfps/[id]/matches/actions.ts

# Types for reference
@src/types/rfp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InventorySearchResult type and searchInventory Server Action</name>
  <files>src/app/(dashboard)/rfps/[id]/matches/actions.ts</files>
  <action>
Add to the existing actions.ts file:

1. Export a new interface `InventorySearchResult`:
```typescript
export interface InventorySearchResult {
  id: string
  codigo_spms: string | null
  artigo: string | null
  descricao: string | null
  unidade_venda: string | null
  preco: number | null
}
```

2. Add `searchInventory` Server Action:
- Accept a `query: string` parameter
- Return early with empty array if query is less than 2 characters
- Verify user is authenticated (consistent with existing actions)
- Query `artigos` table using Supabase `.or()` with `.ilike()` for case-insensitive search across:
  - codigo_spms
  - artigo
  - descricao
- Select only: id, codigo_spms, artigo, descricao, unidade_venda, preco
- Limit to 50 results
- Return `InventorySearchResult[]`
- On error, log and return empty array (graceful degradation)

Follow the existing action pattern in the file (createClient, auth check, error handling).
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Export is available: `grep "export async function searchInventory" src/app/(dashboard)/rfps/[id]/matches/actions.ts`
  </verify>
  <done>searchInventory action exported and accepts query string, returns array of inventory items</done>
</task>

<task type="auto">
  <name>Task 2: Add setManualMatch Server Action</name>
  <files>src/app/(dashboard)/rfps/[id]/matches/actions.ts</files>
  <action>
Add `setManualMatch` Server Action to actions.ts:

1. Function signature:
```typescript
export async function setManualMatch(
  jobId: string,
  rfpItemId: string,
  inventoryItem: InventorySearchResult
): Promise<ActionResult>
```

2. Implementation steps (follow existing acceptMatch pattern):
   a. Create Supabase client and verify authentication
   b. Insert new match suggestion from inventory item:
      - rfp_item_id: rfpItemId
      - codigo_spms: inventoryItem.codigo_spms
      - artigo: inventoryItem.artigo
      - descricao: inventoryItem.descricao
      - unidade_venda: inventoryItem.unidade_venda
      - preco: inventoryItem.preco
      - similarity_score: 1.0 (manual = 100% user confidence)
      - match_type: 'Manual'
      - rank: 0 (top priority)
      - status: 'accepted'
   c. Get the new match ID with `.select('id').single()`
   d. Reject all existing matches for this RFP item (neq new match id)
   e. Update RFP item with:
      - review_status: 'manual'
      - selected_match_id: newMatch.id
   f. Call `revalidatePath(`/rfps/${jobId}/matches`)` to refresh cache
   g. Return `{ success: true }` or `{ success: false, error: message }`

3. Add try/catch wrapper with console.error for debugging

Key difference from acceptMatch: This creates a NEW match record rather than accepting an existing one, and sets review_status to 'manual' not 'accepted'.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Export is available: `grep "export async function setManualMatch" src/app/(dashboard)/rfps/[id]/matches/actions.ts`
Uses 'manual' status: `grep "review_status: 'manual'" src/app/(dashboard)/rfps/[id]/matches/actions.ts`
  </verify>
  <done>setManualMatch action creates new match from inventory item and sets RFP item status to 'manual'</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Both new actions are exported from actions.ts
3. searchInventory returns InventorySearchResult[] type
4. setManualMatch follows same error handling pattern as acceptMatch
5. No changes to existing acceptMatch, rejectMatch, unselectMatch functions
</verification>

<success_criteria>
- searchInventory Server Action searches artigos table and returns results
- setManualMatch Server Action creates manual match and updates item status
- Both actions follow existing auth and error handling patterns
- TypeScript types are properly exported for use in components
</success_criteria>

<output>
After completion, create `.planning/phases/08-bulk-operations/08-01-SUMMARY.md`
</output>
